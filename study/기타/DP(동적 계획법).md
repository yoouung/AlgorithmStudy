### Dynamic Programing

복잡한 문제를 여러 개의 간단한 문제로 분리하여 부분의 문제들을 해결함으로써 최종적으로 복잡한 문제의 답을 구하는 방법

-   **핵심 이론**

    1. `분할정복`: 큰 문제를 작은 문제로 나눌 수 있어야 한다.
    2. `메모이제이션(Memoization)`: 작은 문제들이 반복되어 나타나고 사용되며, 이 작은 문제들의 결과값은 항상 동일해야 한다.
    3. 모든 작은 문제들은 한 번의 계산해 DP 테이블에 저장하며, 추후 재사용할 때는 이 DP 테이블을 활용한다.
    4. `Top-Down`과 `Bottom-Up` 방식으로 구현 가능

    -   **Top-Down**: 재귀함수를 이용하여 작은 문제를 해결하고, 그 결과를 저장하여 중복 계산을 줄임
    -   **Bottom-Up**: 작은 문제부터 차례대로 해결하며, 결과를 저장하여 중복 계산을 줄임

-   **예시 문제**  
    피보나치 수열, 이항계수, 최대 부분 증가 수열(LIS), 최대 연속합 등
-   **시간복잡도**: $O(N)$
-   **공간복잡도**: $O(N)$
-   **주의사항**: 재귀함수를 사용할 때, **재귀 깊이**에 대한 제한이 있으므로, **sys.setrecursionlimit()**을 이용하여 재귀 깊이를 설정해주어야 함

<br/>

-   피보나치 수열(Fibonacci Sequence)

    -   **점화식**: $F(n) = F(n-1) + F(n-2)$
    -   **초기값**: $F(0) = 0, F(1) = 1$
    -   **Top-Down**: 재귀함수를 이용하여 구현
    -   **Bottom-Up**: 반복문을 이용하여 구현
    -   **시간복잡도**: $O(N)$
    -   **공간복잡도**: $O(N)$

-   이항계수(Binomial Coefficient)

    -   **점화식**: $C(n, k) = C(n-1, k-1) + C(n-1, k)$
    -   **초기값**: $C(n, 0) = C(n, n) = 1$
    -   **Top-Down**: 재귀함수를 이용하여 구현
    -   **Bottom-Up**: 반복문을 이용하여 구현
    -   **시간복잡도**: $O(N^2)$
    -   **공간복잡도**: $O(N^2)$

-   최대 부분 증가 수열(Longest Increasing Subsequence, LIS)

    -   **점화식**: $dp[i] = max(dp[i], dp[j] + 1)$, $(0 \leq j < i)$
    -   **초기값**: $dp[i] = 1$
    -   **Top-Down**: 재귀함수를 이용하여 구현
    -   **Bottom-Up**: 반복문을 이용하여 구현
    -   **시간복잡도**: $O(N^2)$
    -   **공간복잡도**: $O(N)$

-   최대 연속합(Maximum Subarray)

    -   **점화식**: $dp[i] = max(dp[i-1] + arr[i], arr[i])$
    -   **초기값**: $dp[0] = arr[0]$
    -   **Top-Down**: 재귀함수를 이용하여 구현
    -   **Bottom-Up**: 반복문을 이용하여 구현
    -   **시간복잡도**: $O(N)$
    -   **공간복잡도**: $O(N)$

<br/>

-   **예시 문제**
    -   **[피보나치 수열](https://www.acmicpc.net/problem/2747)**
    -   **[이항계수](https://www.acmicpc.net/problem/11050)**
    -   **[최대 부분 증가 수열](https://www.acmicpc.net/problem/11053)**
    -   **[최대 연속합](https://www.acmicpc.net/problem/1912)**
    -   **[가장 긴 증가하는 부분 수열 4](https://www.acmicpc.net/problem/14002)**
